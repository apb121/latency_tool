code stuff

-- !! see what the compiler says about the size of structs that contain each other

-- suggestions
    -- inline some functions (then they will not conflict!)
    -- move functions around (put function that are called together together)
    -- combine functions
    -- try -falign-functions=...
    -- forcibly stop some functions coming into the cache with non temporal code accesses??
-- source code (class) parser
    -- inherit size from parent classes, increase size by any size of new data members...
    -- (NB regex is equivalent to FSM and therefore can't handle arbitrarily recursive structures that require counting)
    -- (keep virtual in there and discard it)
    -- add template functionality to class/variable search
        -- suggest specialisations?
    -- classes as members of other classes
    -- avoid virtual declarations
    -- many-level recursive array<>s
    -- comma separated lists of variables
-- empirical cache tests
    -- more sophisticated stddev checking for spikes?
-- binary analyser
    -- next do: coexecutes with and competes with
    -- also: more levels of coexecutes with
    -- makefile functionality?
    -- nm function functionality
        -- which functions are called near to each other
        -- consider: overloading
        -- consider: templates!
    -- better to use objdump for many reasons
        -- a lot of function calls (e.g. to constructors, assignment operators, etc.) are not explicit in source code
            -- particularly useful because it can identify slow-downs that could never been seen just by looking at the source code. constructors might conflict!
    -- need to incorporate:
        -- how many times functions call each other
        -- how much functions overlap
    -- interesting demonstrations of function group identifier
        -- compare aligned functions perfomance with nCr (e.g., groups of size 3 from 17 competing and coexecuting functions (1 extra level of indirection) leads to 680 groups found!)
        -- compare critical stride tests 1024, 2048, and 4096!
            -- note also that for 1024, you get groups at 4-function intervals!
        -- cool: for the critical stride 1024 test and looking for groups of 9 ... there is 1! (for groups of 8 there are 12 groups)
        -- when commenting out the function "for (auto& i : problem_groups)", the number of 6-large groups of competing functions goes down from 14 to 6
-- identify discontiguous data structures

report stuff

--emphasise the difficulty of catching appropriate cases of variable declarations and rejecting inappropriate cases
    -- inline functions
    -- function parameters
    -- complex cases (see notebook)
    -- using nm and objdump
--try to optimise OOP coursework!