-- the number of groups of particular sizes at, e.g., 256, 512, 1024, 2048, 4096 aligned functions is a new way to visualise the cache problems associated with those alignments
    -- specifically
        -- at 512, there is one competing coexecuting group of 5 functions, and many of 4 and below
        -- at 1024, there is one group of 9, and several of 8, etc.

-- also demonstrate that simply moving functions around in the code can change the number of problem functions

report stuff (talking points)

-- change bitflag ints to #define s

-- challenges
    -- cache info
        -- class structure in my code
            -- class hierarchy
            -- currently unused class types to add later extensibility to other caches
        -- different cache structures
        -- missing system variables!
            -- show sysconf code
            -- sometimes associativity is just... missing from the system variables
        --testing values empirically
            -- data cache associativity
                -- show code
                -- setup
                    -- g++ -g ./test_files/associativity_test_d.cpp -o ./temp_files/associativity_test_d
                    -- perf stat -x , --append -o ./temp_files/assoctmpd.txt -e L1-dcache-load-misses -r 1000 ./temp_files/associativity_test_d <16 or 65536 alignment>
                -- best measure: cache miss percentage
                    -- minimum of
                        -- first jump in 65536 (raw cache miss percentage)
                        -- highest standard deviation in cache miss percentage
                            -- show graphs from first part
            -- data cache critical stride (even though you can work out from associativity)
                -- show code
                -- setup
                    -- g++ -g ./test_files/critical_stride_test_d.cpp -o ./temp_files/critical_stride_test_d
                    -- perf stat -x , --append -o ./temp_files/cstmpd.txt -e L1-dcache-loads,L1-dcache-load-misses,duration_time -r 1000 ./temp_files/critical_stride_test_d <64, 128, 256, ... 65536>
                --best measure:
                    -- highest standard deviation of cache miss percentage is a quarter of the critical stride
            -- instruction cache associativity
                -- show code
                    -- g++ -g -falign-functions=65536 ./test_files/associativity_test_i.cpp -o ./temp_files/associativity_test_i_65536 
                    -- g++ -g ./test_files/associativity_test_i.cpp -o ./temp_files/associativity_test_i_noalign 
                    -- perf stat -x , --append -o ./temp_files/assoctmpi.txt -e L1-icache-load-misses -r 1000 ./temp_files/associativity_test_i_65536 
                    -- perf stat -x , --append -o ./temp_files/assoctmpi.txt -e L1-icache-load-misses -r 1000 ./temp_files/associativity_test_i_noalign 
                -- best measure:
                    -- same as data cache associativity
            -- instruction cache critical stride
                -- show code
                -- setup
                    -- g++ -g -falign-functions= <64, 128, 256, ... 65536> ./test_files/critical_stride_test_i.cpp -o ./temp_files/critical_stride_test_i_
                    -- perf stat -x , --append -o ./temp_files/cstmpi.txt -e L1-icache-load-misses -r 1000 ./temp_files/critical_stride_test_i_
                -- best measure:
                    -- last large jump in absolute number of instruction cache misses (can't view standard deviation...)
            -- empirical tests general
                -- how to choose critical stride direct or size / assoc
                    -- powers of two? (see code)
    -- class parser
        -- original attempt
            -- detecting classes
                -- regex: "(class|struct)\\s*([a-zA-Z_][a-zA-Z0-9_]*)\\s*(:\\s*(public|protected|private)\\s*([a-zA-Z_][a-zA-Z0-9_]*)\\s*)?\\{"
                    -- recursion to find balanced brackets
                        -- regular expressions, like FSMs cannot do counting
                            -- so it's only really possible to detect the start of a class with regex
                                -- end of a class: } <variable name> ;
                -- inbuilt types
                    
                -- class hierarchies
                -- user defined types containing other types
                -- other code parsing issues
                    -- ignoring things in speech marks... but not based on speech marks that are themselves in speech marks!
            -- detecting types and calculating their sizes
                -- regex "(?:(?:virtual *|auto *|static *|const *|unsigned *|signed *|register *|volatile *|void *\\* *|bitset *<.*> *|array *<.*> *|std::vector *<.*> *|deque *<.*> *|forward_list *<.*> *|list *<.*> *|stack *<.*> *|queue *<.*> *|priority_queue *<.*> *|set *<.*> *|multiset *<.*> *|map *<.*> *|multimap *<.*> *|unordered_set *<.*> *|unordered_multiset *<.*> *|unordered_map *<.*> *|unordered_multimap *<.*> *|size_t *|std::string *|short *|long *|char *|wchar_t *|char8_t *|char16_t *|int *|float *|double *| bool *|complex *)+)[\\*]*(?: +\\*?\\*? *)( *const *)?([a-zA-Z_][a-zA-Z0-9_]*) *(([{;,=])|(((\\[ *[0-9]* *\\])+)))"
                    -- putting user defined types in the middle!
                -- some tricks
                    -- ignore anything in curly brackets
                -- function parameters
                    -- func(int a = 5, char g = 'f')
                -- variable declarations inside functions (especially inline)
                -- pointers
                    -- vector<normal> vs vector<bool>
                    -- asterisks inside template parameters vs outside them
                        -- vector<string*> vs vector<string>*
                    -- char const * const * c;
                -- pure virtual functions
                    -- virtual int function = 0;
                    -- keep virtual in the regex and discard later
                -- array lengths
                    -- char a[5]
                    -- vector<char[5]> vs vector<char>[5]
                -- static variables
                -- parent/child class hierarchies
                    -- use parents to calculate size of children
                -- array<array<char[5], 6>, 7>[3]
                    -- aligns by char!
                -- user defined types inside user-defined types
                    -- iterative building these into the checkers
                -- remaining issues
                    -- comma separated declarations
                    -- add template functionality to class/variable search
                        -- suggest specialisations?
                    -- many-level recursive array<>s
                    -- comma separated lists of variables
            -- alignments
                -- vector<char[5]>, e.g., aligns by char
            -- reordering
        -- using llvm-dwarfdump
            -- complex parsing
            -- files much too large to process in a timely fashion
        -- using gdb command
            -- more parsing
    -- binary analyser
        -- identify functions
            -- nm -v -C -l --radix=d --print-size <filename> > ./temp_files/nmtmp.txt
                -v ordering by address
                -C name demangler
                -- (note duplicates... and use of map/set)
            -- show output
            -- question: library functions?
            -- using class names identified from source code analysis
        -- identifying relations between functions
            -- objdump -d -C -Mintel --no-show-raw-insn <filename> > ./temp_files/objdumptmp.txt
                -d disassemble
                -C demangle
            -- very basic assembly parsing to find function calls
            -- populating "coexecution vectors"
        -- identifying functions that compete for memory (minimum competition thresholds...)
            -- using the coexecution vectors and filtering to find which functions span which portions of the cache (coexecution indirection levels...)
                -- combining the two to find groups of functions that call each other and evict each other from the cache
                    -- weighting (and ranking) number of coexecuting functions and amount of competition in bytes
    -- user flags!
        -- warnings for potentially problematic flag choices
        -- e.g.,
            -- high indirection numbers
            -- low competition thresholds
            -- large ranking lengths
    -- defaults
    -- flow of information
        -- esp: how different parts use each others' information
            -- cache analysis
                -- source code analysis uses cache analysis
                -- binary analysis uses cache analysis and the output of the source code analysis (class names)
    -- all feeds back to suggestions that are tailored to
        -- specific source code
        -- specific compiled binary
        -- specific processor
            -- but all these options are customisable and toggleable
    -- lots of robustness checks

-- make a readme!

-- overall programme stuff
    -- put the suggestions in the standard output
        -- after the binary analysis put:
            -- suggestions
                -- inline some functions (then they will not conflict! may also have other advantages...)
                -- move functions around (put function that are called together together)
                -- combine functions
                -- try -falign-functions=...
                -- (forcibly stop some functions coming into the cache with non temporal code accesses??)
    -- make the temp files only overwrite the old temp file at the end (with cp)
        -- so that if the programme is aborted halfway it isn't a problem...
    -- add checks for if data/instruction cache info is present in the analysis functions
    -- might be better if the binary is the first file?
    -- add makefile functionality (programme executes make?)
    -- give the user the option to combine the system variables and known, manually-input specific values ??
    -- make it so that not having the size of one of the caches is not fatal (just do data/instructions if the other is missing)
    -- factor out all the stuff in main if possible
    -- slash-star comments... (see both/all places where characters (usu. brackets) in comments are ignored)
    -- slash-slash comments
    -- size of classes that contain UDTypes as members!
    -- calculate number of coexecutions of a problem group... (to evaluate problematicness with overlap extent and overall size of group)
    -- have a think about the binary only flag and doing all functions (i.e., including 'W' rather than just 'T') 
-- suggestions
-- source code (class) parser

-- empirical cache tests
    -- more sophisticated stddev checking for spikes?
-- binary analyser
    -- makefile functionality?
    -- nm function functionality
        -- which functions are called near to each other
        -- consider: overloading
        -- consider: templates!
    -- better to use objdump for many reasons
        -- a lot of function calls (e.g. to constructors, assignment operators, multiple functions from templates, etc.) are not explicit in source code
            -- particularly useful because it can identify slow-downs that could never been seen just by looking at the source code. constructors might conflict!
        -- avoids wasting time on functions written but never called (these are not compiled into the binary)
    -- interesting demonstrations of function group identifier
        -- compare aligned functions perfomance with nCr (e.g., groups of size 3 from 17 competing and coexecuting functions (1 extra level of indirection) leads to 680 groups found!)
        -- compare critical stride tests 1024, 2048, and 4096!
            -- note also that for 1024, you get groups at 4-function intervals!
        -- cool: for the critical stride 1024 test and looking for groups of 9 ... there is 1! (for groups of 8 there are 12 groups)
        -- when commenting out the function "for (auto& i : problem_groups)", the number of 6-large groups of competing functions goes down from 14 to 6
-- identify discontiguous data structures

