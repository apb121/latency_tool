report stuff (talking points)

-- change bitflag ints to #define s

-- challenges
    -- cache info
        -- class structure in my code
            -- class hierarchy
        -- different cache structures
        -- missing system variables!
            -- show sysconf code
            -- sometimes associativity is just... missing from the system variables
        --testing values empirically
            -- data cache associativity
                -- show code
                -- setup
                    -- g++ -g ./test_files/associativity_test_d.cpp -o ./temp_files/associativity_test_d
                    -- perf stat -x , --append -o ./temp_files/assoctmpd.txt -e L1-dcache-load-misses -r 1000 ./temp_files/associativity_test_d <16 or 65536 alignment>
                -- best measure: cache miss percentage
                    -- minimum of
                        -- first jump in 65536 (raw cache miss percentage)
                        -- highest standard deviation in cache miss percentage
                            -- show graphs from first part
            -- data cache critical stride (even though you can work out from associativity)
                -- show code
                -- setup
                    -- g++ -g ./test_files/critical_stride_test_d.cpp -o ./temp_files/critical_stride_test_d
                    -- perf stat -x , --append -o ./temp_files/cstmpd.txt -e L1-dcache-loads,L1-dcache-load-misses,duration_time -r 1000 ./temp_files/critical_stride_test_d <64, 128, 256, ... 65536>
                --best measure:
                    -- highest standard deviation of cache miss percentage is a quarter of the critical stride
            -- instruction cache associativity
                -- show code
                    -- g++ -g -falign-functions=65536 ./test_files/associativity_test_i.cpp -o ./temp_files/associativity_test_i_65536 
                    -- g++ -g ./test_files/associativity_test_i.cpp -o ./temp_files/associativity_test_i_noalign 
                    -- perf stat -x , --append -o ./temp_files/assoctmpi.txt -e L1-icache-load-misses -r 1000 ./temp_files/associativity_test_i_65536 
                    -- perf stat -x , --append -o ./temp_files/assoctmpi.txt -e L1-icache-load-misses -r 1000 ./temp_files/associativity_test_i_noalign 
                -- best measure:
                    -- same as data cache associativity
            -- instruction cache critical stride
                -- show code
                -- setup
                    -- g++ -g -falign-functions= <64, 128, 256, ... 65536> ./test_files/critical_stride_test_i.cpp -o ./temp_files/critical_stride_test_i_
                    -- perf stat -x , --append -o ./temp_files/cstmpi.txt -e L1-icache-load-misses -r 1000 ./temp_files/critical_stride_test_i_
                -- best measure:
                    -- last large jump in absolute number of instruction cache misses (can't view standard deviation...)
            -- empirical tests general
                -- how to choose critical stride direct or size / assoc
                    -- powers of two? (see code)
    -- class parser
        -- detecting classes
            -- regex: "(class|struct)\\s*([a-zA-Z_][a-zA-Z0-9_]*)\\s*(:\\s*(public|protected|private)\\s*([a-zA-Z_][a-zA-Z0-9_]*)\\s*)?\\{"
                -- recursion to find balanced brackets
                    -- regular expressions, like FSMs cannot do counting
                        -- so it's only really possible to detect the start of a class with regex
                            -- end of a class: } <variable name> ;
            -- inbuilt types
                
            -- class hierarchies
            -- user defined types containing other types
            -- other code parsing issues
                -- ignoring things in speech marks... but not based on speech marks that are themselves in speech marks!
        -- detecting types and calculating their sizes
            -- regex "(?:(?:virtual *|auto *|static *|const *|unsigned *|signed *|register *|volatile *|void *\\* *|bitset *<.*> *|array *<.*> *|std::vector *<.*> *|deque *<.*> *|forward_list *<.*> *|list *<.*> *|stack *<.*> *|queue *<.*> *|priority_queue *<.*> *|set *<.*> *|multiset *<.*> *|map *<.*> *|multimap *<.*> *|unordered_set *<.*> *|unordered_multiset *<.*> *|unordered_map *<.*> *|unordered_multimap *<.*> *|size_t *|std::string *|short *|long *|char *|wchar_t *|char8_t *|char16_t *|int *|float *|double *| bool *|complex *)+)[\\*]*(?: +\\*?\\*? *)( *const *)?([a-zA-Z_][a-zA-Z0-9_]*) *(([{;,=])|(((\\[ *[0-9]* *\\])+)))"
                -- putting user defined types in the middle!
            -- some tricks
                -- ignore anything in curly brackets
            
            -- function parameters
                -- func(int a = 5, char g = 'f')
            -- variable declarations inside functions (especially inline)
            -- pointers
                -- vector<normal> vs vector<bool>
                -- asterisks inside template parameters vs outside them
                    -- vector<string*> vs vector<string>*
                -- char const * const * c;
            -- pure virtual functions
                -- virtual int function = 0;
            -- array lengths
                -- char a[5]
                -- vector<char[5]> vs vector<char>[5]
            -- static variables
            -- parent/child class hierarchies
            -- array<array<char[5], 6>, 7>[3]
                -- aligns by char!
            -- user defined types??
                -- iterative building these into the checkers
            -- remaining issues
                -- recursive array<>
                -- comma separated declarations
        -- alignments
            -- vector<char[5]>, e.g., aligns by char
        -- reordering
    -- binary analyser
        -- identify functions
            -- nm -v -C -l --radix=d --print-size <filename> > ./temp_files/nmtmp.txt
                -v ordering by address
                -C name demangler
                -- (note duplicates... and use of map/set)
            -- show output
            -- question: library functions?
            -- using class names identified from source code analysis
        -- identifying relations between functions
            -- objdump -d -C -Mintel --no-show-raw-insn <filename> > ./temp_files/objdumptmp.txt
                -d disassemble
                -C demangle
            -- very basic assembly parsing to find function calls
            -- populating "coexecution vectors"
        -- identifying functions that compete for memory (minimum competition thresholds...)
            -- using the coexecution vectors and filtering to find which functions span which portions of the cache (coexecution indirection levels...)
                -- combining the two to find groups of functions that call each other and evict each other from the cache
                    -- weighting (and ranking) number of coexecuting functions and amount of competition in bytes
    -- user flags!
    -- defaults
    -- flow of information
        -- esp: how different parts use each others' information
            -- cache analysis
                -- source code analysis uses cache analysis
                -- binary analysis uses cache analysis and the output of the source code analysis (class names)
    -- all feeds back to suggestions that are tailored to
        -- specific source code
        -- specific compiled binary
        -- specific processor
            -- but all these options are customisable and toggleable
    -- lots of robustness checks

--emphasise the difficulty of catching appropriate cases of variable declarations and rejecting inappropriate cases
    -- inline functions
    -- function parameters
    -- complex cases (see notebook)
    -- using nm and objdump
--try to optimise OOP coursework!

code stuff

-- make hacky overloading of calculate_size() better

-- make the optimise data ordering function more efficient

-- add warnings for potentially problematic flag choices
    -- e.g.,
        -- high indirection numbers
        -- low competition thresholds
        -- large ranking lengths

-- print explanations out to read while processing is taking place

-- source code analyser
    -- optimisation: get things that are at the moment being calculated every time to sometimes return just a value
        -- e.g. calculate_size and parent_size, etc.
            -- in fact within the calculate size function it could check if the stored size is 0
                -- at the end of the function if all checks have passed, only then is the value of size in the class is changed from 0

-- make a readme!

-- main needs serious structural cleanup
    -- maybe put the stuff in the UDType class

-- overall programme stuff
    -- put the suggestions in the standard output
        -- after the binary analysis put:
            -- explanation
                -- groups of coexecuting and competing functions near the associativity cause jitter
                -- groups of coexecuting and competing functions above the associativity are guaranteed to evict each other from the cache and therefore cause latency issues
            -- suggestions
                -- inline some functions (then they will not conflict! may also have other advantages...)
                -- move functions around (put function that are called together together)
                -- combine functions
                -- try -falign-functions=...
                -- forcibly stop some functions coming into the cache with non temporal code accesses??
    -- make the temp files only overwrite the old temp file at the end (with cp)
        -- so that if the programme is aborted halfway it isn't a problem...
    -- add checks for if data/instruction cache info is present in the analysis functions
    -- might be better if the binary is the first file?
    -- add makefile functionality (programme executes make?)
    -- give the user the option to combine the system variables and known, manually-input specific values ??
    -- make it so that not having the size of one of the caches is not fatal (just do data/instructions if the other is missing)
    -- factor out all the stuff in main if possible
    -- slash-star comments... (see both/all places where characters (usu. brackets) in comments are ignored)
    -- slash-slash comments
    -- size of classes that contain UDTypes as members!
    -- calculate number of coexecutions of a problem group... (to evaluate problematicness with overlap extent and overall size of group)
    -- have a think about the binary only flag and doing all functions (i.e., including 'W' rather than just 'T') 
-- suggestions
-- source code (class) parser
    -- inherit size from parent classes, increase size by any size of new data members...
    -- (NB regex is equivalent to FSM and therefore can't handle arbitrarily recursive structures that require counting)
    -- (keep virtual in there and discard it)
    -- add template functionality to class/variable search
        -- suggest specialisations?
    -- classes as members of other classes
    -- many-level recursive array<>s
    -- comma separated lists of variables
-- empirical cache tests
    -- more sophisticated stddev checking for spikes?
-- binary analyser
    -- makefile functionality?
    -- nm function functionality
        -- which functions are called near to each other
        -- consider: overloading
        -- consider: templates!
    -- better to use objdump for many reasons
        -- a lot of function calls (e.g. to constructors, assignment operators, multiple functions from templates, etc.) are not explicit in source code
            -- particularly useful because it can identify slow-downs that could never been seen just by looking at the source code. constructors might conflict!
        -- avoids wasting time on functions written but never called (these are not compiled into the binary)
    -- need to incorporate:
        -- how many times functions call each other
    -- interesting demonstrations of function group identifier
        -- compare aligned functions perfomance with nCr (e.g., groups of size 3 from 17 competing and coexecuting functions (1 extra level of indirection) leads to 680 groups found!)
        -- compare critical stride tests 1024, 2048, and 4096!
            -- note also that for 1024, you get groups at 4-function intervals!
        -- cool: for the critical stride 1024 test and looking for groups of 9 ... there is 1! (for groups of 8 there are 12 groups)
        -- when commenting out the function "for (auto& i : problem_groups)", the number of 6-large groups of competing functions goes down from 14 to 6
-- identify discontiguous data structures

