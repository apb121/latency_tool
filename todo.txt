code stuff

-- make a readme!

-- overall programme stuff
    -- make the temp files only overwrite the old temp file at the end (with cp)
        -- so that if the programme is aborted halfway it isn't a problem...
    -- add checks for if data/instruction cache info is present in the analysis functions
    -- implement the -k flag
    -- might be better if the binary is the first file?
    -- factor stuff in all the hpps into hpps and cpps
        -- make a makefile!
            -- perhaps think about this in the context of adding makefile functionality to the programme...
    -- give the user the option to combine the system variables and known, manually-input specific values ??
    -- make it so that not having the size of one of the caches is not fatal (just do data/instructions if the other is missing)
    -- factor out all the stuff in main if possible
    -- support for size of bitset ??
    -- slash-star comments... (see both/all places where characters (usu. brackets) in comments are ignored)
    -- slash-slash comments
    -- size of classes that contain UDTypes as members!
    -- calculate number of coexecutions of a problem group... (to evaluate problematicness with overlap extent and overall size of group)
    -- have a think about the binary only flag and doing all functions (i.e., including 'W' rather than just 'T') 
-- suggestions
    -- inline some functions (then they will not conflict! may also have other advantages...)
    -- move functions around (put function that are called together together)
    -- combine functions
    -- try -falign-functions=...
    -- forcibly stop some functions coming into the cache with non temporal code accesses??
-- source code (class) parser
    -- inherit size from parent classes, increase size by any size of new data members...
    -- (NB regex is equivalent to FSM and therefore can't handle arbitrarily recursive structures that require counting)
    -- (keep virtual in there and discard it)
    -- add template functionality to class/variable search
        -- suggest specialisations?
    -- classes as members of other classes
    -- avoid virtual declarations
    -- many-level recursive array<>s
    -- comma separated lists of variables
-- empirical cache tests
    -- more sophisticated stddev checking for spikes?
-- binary analyser
    -- next do: coexecutes with and competes with
    -- also: more levels of coexecutes with
    -- makefile functionality?
    -- nm function functionality
        -- which functions are called near to each other
        -- consider: overloading
        -- consider: templates!
    -- better to use objdump for many reasons
        -- a lot of function calls (e.g. to constructors, assignment operators, etc.) are not explicit in source code
            -- particularly useful because it can identify slow-downs that could never been seen just by looking at the source code. constructors might conflict!
        -- avoids wasting time on functions written but never called (these are not compiled into the binary)
    -- need to incorporate:
        -- how many times functions call each other
        -- how much functions overlap
    -- interesting demonstrations of function group identifier
        -- compare aligned functions perfomance with nCr (e.g., groups of size 3 from 17 competing and coexecuting functions (1 extra level of indirection) leads to 680 groups found!)
        -- compare critical stride tests 1024, 2048, and 4096!
            -- note also that for 1024, you get groups at 4-function intervals!
        -- cool: for the critical stride 1024 test and looking for groups of 9 ... there is 1! (for groups of 8 there are 12 groups)
        -- when commenting out the function "for (auto& i : problem_groups)", the number of 6-large groups of competing functions goes down from 14 to 6
-- identify discontiguous data structures

report stuff

--emphasise the difficulty of catching appropriate cases of variable declarations and rejecting inappropriate cases
    -- inline functions
    -- function parameters
    -- complex cases (see notebook)
    -- using nm and objdump
--try to optimise OOP coursework!